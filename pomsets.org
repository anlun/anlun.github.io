#+TITLE: Examples of pomsets from Podkopaev-al:draft
#+OPTIONS: author:nil email:nil creator:nil timestamp:nil html-postamble:nil

* Message-Passing (MP)
** With relaxed modifiers (MP rlx+na)
#+BEGIN_SRC pascal
  f_rlx := 0; d_na := 0;
d_na  := 5; || repeat f_rlx end;
f_rlx := 1  || r = d_na
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-mp-rlx+na
| a | f_rlx := 0 |
| b | d_na  := 0 |
| c | d_na  := 5 |
| d | f_rlx := 1 |
| e | f_rlx  = 0 |
| f | ...        |
| g | f_rlx  = 0 |
| h | f_rlx  = 1 |
| i | d_na   = v |

#+name: edge-table-mp-rlx+na
| a | d |
| a | e |
| e | f |
| f | g |
| g | h |
| b | c |
| b | i |

#+name: make-mp-rlx+na
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-mp-rlx+na :var edge-table=edge-table-mp-rlx+na :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/mp-rlx+na.png :var input=make-mp-rlx+na :exports results
digraph {
 $input
}
#+END_SRC

** With relaxed and release modifiers (MP rel+rlx+na)
#+BEGIN_SRC pascal
  f_rlx := 0; d_na := 0;
d_na  := 5; || repeat f_rlx end;
f_rel := 1  || r = d_na
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-mp-rel+rlx+na
| a | f_rlx := 0 |
| b | d_na  := 0 |
| c | d_na  := 5 |
| d | f_rel := 1 |
| e | f_rlx  = 0 |
| f | ...        |
| g | f_rlx  = 0 |
| h | f_rlx  = 1 |
| i | d_na   = v |

#+name: edge-table-mp-rel+rlx+na
| a | d |
| a | e |
| e | f |
| f | g |
| g | h |
| b | c |
| b | i |
| c | d |

#+name: make-mp-rel+rlx+na
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-mp-rel+rlx+na :var edge-table=edge-table-mp-rel+rlx+na :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/mp-rel+rlx+na.png :var input=make-mp-rel+rlx+na :exports results
digraph {
  { rank = same; a; b; }
  $input
}
#+END_SRC
** With relaxed and acquire modifiers (MP acq+rlx+na)
#+BEGIN_SRC pascal
  f_rlx := 0; d_na := 0;
d_na  := 5; || repeat f_acq end;
f_rlx := 1  || r = d_na
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-mp-acq+rlx+na
| a | f_rlx := 0 |
| b | d_na  := 0 |
| c | d_na  := 5 |
| d | f_rlx := 1 |
| e | f_acq  = 0 |
| f | ...        |
| g | f_acq  = 0 |
| h | f_acq  = 1 |
| i | d_na   = v |

#+name: edge-table-mp-acq+rlx+na
| a | d |
| a | e |
| e | f |
| f | g |
| g | h |
| b | c |
| b | i |
| h | i |

#+name: make-mp-acq+rlx+na
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-mp-acq+rlx+na :var edge-table=edge-table-mp-acq+rlx+na :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/mp-acq+rlx+na.png :var input=make-mp-acq+rlx+na :exports results
digraph {
  { rank = same; a; b; }
  $input
}
#+END_SRC
** With release and acquire modifiers (MP rel+acq+na)
#+BEGIN_SRC pascal
  f_rel := 0; d_na := 0;
d_na  := 5; || repeat f_acq end;
f_rel := 1  || r = d_na
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-mp-rel+acq+na
| a | f_rel := 0 |
| b | d_na  := 0 |
| c | d_na  := 5 |
| d | f_rel := 1 |
| e | f_acq  = 0 |
| f | ...        |
| g | f_acq  = 0 |
| h | f_acq  = 1 |
| i | d_na   = v |

#+name: edge-table-mp-rel+acq+na
| a | d |
| a | e |
| e | f |
| f | g |
| g | h |
| b | c |
| b | i |
| c | d |
| h | i |

#+name: make-mp-rel+acq+na
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-mp-rel+acq+na :var edge-table=edge-table-mp-rel+acq+na :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/mp-rel+acq+na.png :var input=make-mp-rel+acq+na :exports results
digraph {
  { rank = same; a; b; }
  $input
}
#+END_SRC
** With release, acquire, and relaxed modifiers (MP rel+acq+na+rlx)
#+BEGIN_SRC pascal
  f_rel := 0; d_na := 0;
d_na  := 5; || repeat f_acq end;
f_rel := 1; || r = d_na
f_rlx := 2  ||
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-mp-rel+acq+na+rlx
| a | f_rel := 0 |
| b | d_na  := 0 |
| c | d_na  := 5 |
| d | f_rel := 1 |
| j | f_rlx := 2 |
| e | f_acq  = 0 |
| f | ...        |
| g | f_acq  = 0 |
| h | f_acq  = 1 |
| i | d_na   = v |

#+name: edge-table-mp-rel+acq+na+rlx
| a | d |
| a | e |
| e | f |
| f | g |
| g | h |
| b | c |
| b | i |
| c | d |
| h | i |
| d | j |

#+name: make-mp-rel+acq+na+rlx
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-mp-rel+acq+na+rlx :var edge-table=edge-table-mp-rel+acq+na+rlx :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/mp-rel+acq+na+rlx.png :var input=make-mp-rel+acq+na+rlx :exports results
digraph {
  { rank = same; a; b; }
  $input
}
#+END_SRC
* Load Buffering (LB)
** With relaxed modifiers (LB rlx)
#+BEGIN_SRC pascal
  x_rlx := 0; y_rlx := 0;
r1 = y_rlx; || r2 = x_rlx;
x_rlx := 1  || y_rlx := 1
#+END_SRC

#+BEGIN_COMMENT
#+name: vertex-table-lb-rlx
| a | x_rlx := 0   |
| b | y_rlx := 0   |
| c | y_rlx  = v_1 |
| d | x_rlx := 1   |
| e | x_rlx  = v_2 |
| f | y_rlx := 1   |

#+name: edge-table-lb-rlx
| a | d |
| a | e |
| b | f |
| b | c |

#+name: make-lb-rlx
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-lb-rlx :var edge-table=edge-table-lb-rlx :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/lb-rlx.png :var input=make-lb-rlx :exports results
digraph {
 $input
}
#+END_SRC
** With release and relaxed modifiers (LB rel+rlx) <<LB rel+rlx>>
#+BEGIN_SRC pascal
  x_rlx := 0; y_rlx := 0;
r1 = y_rlx; || r2 = x_rlx;
x_rel := 1  || y_rel := 1
#+END_SRC

It should be possible to get ~r1 = r2 = 1~ (=v_1= and =v_2=).
Because of that there should be no edges between reads and writes
in left and right subthreads. 

#+BEGIN_COMMENT
#+name: vertex-table-lb-rel+rlx
| a | x_rlx := 0   |
| b | y_rlx := 0   |
| c | y_rlx  = v_1 |
| d | x_rel := 1   |
| e | x_rlx  = v_2 |
| f | y_rel := 1   |

#+name: edge-table-lb-rel+rlx
| a | d |
| a | e |
| b | f |
| b | c |

#+name: make-lb-rel+rlx
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-lb-rel+rlx :var edge-table=edge-table-lb-rel+rlx :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/lb-rel+rlx.png :var input=make-lb-rel+rlx :exports results
digraph {
 { rank = same; a; b; }
 $input
}
#+END_SRC
** With acquire and relaxed modifiers (LB acq+rlx) <<LB acq+rlx>>
#+BEGIN_SRC pascal
  x_rlx := 0; y_rlx := 0;
r1 = y_acq; || r2 = x_acq;
x_rlx := 1  || y_rlx := 1
#+END_SRC

It should be possible to get ~r1 = r2 = 1~ (=v_1= and =v_2=).
Because of that there should be no edges between reads and writes
in left and right subthreads. 

#+BEGIN_COMMENT
#+name: vertex-table-lb-acq+rlx
| a | x_rlx := 0   |
| b | y_rlx := 0   |
| c | y_acq  = v_1 |
| d | x_rlx := 1   |
| e | x_acq  = v_2 |
| f | y_rlx := 1   |

#+name: edge-table-lb-acq+rlx
| a | d |
| a | e |
| b | f |
| b | c |

#+name: make-lb-acq+rlx
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-lb-acq+rlx :var edge-table=edge-table-lb-acq+rlx :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/lb-acq+rlx.png :var input=make-lb-acq+rlx :exports results
digraph {
 { rank = same; a; b; }
 $input
}
#+END_SRC
** With release, acquire, and relaxed modifiers (LB rel+acq+rlx) <<LB rel+acq+rlx>>
#+BEGIN_SRC pascal
  x_rlx := 0; y_rlx := 0;
r1 = y_acq; || r2 = x_rlx;
x_rlx := 1  || y_rel := 1
#+END_SRC

*Problem:* C11 outlaws ~r1 = r2 = 1~ (=v_1= and =v_2=) outcome for the snippet,
but the pomset doesn't address it.

#+BEGIN_COMMENT
#+name: vertex-table-lb-rel+acq+rlx
| a | x_rlx := 0   |
| b | y_rlx := 0   |
| c | y_acq  = v_1 |
| d | x_rlx := 1   |
| e | x_rlx  = v_2 |
| f | y_rel := 1   |

#+name: edge-table-lb-rel+acq+rlx
| a | d |
| a | e |
| b | f |
| b | c |

#+name: make-lb-rel+acq+rlx
#+BEGIN_SRC emacs-lisp :var vertex-table=vertex-table-lb-rel+acq+rlx :var edge-table=edge-table-lb-rel+acq+rlx :results output :exports none
  (mapcar #'(lambda (x)
              (princ (format "%s [label =\"%s\", shape = \"box\"];\n"
                             (first x) (second x)))) vertex-table)
  (princ "edge [arrowhead=normal,arrowtail=dot];\n")
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s;\n"
                             (first x) (second x)))) edge-table)
#+END_SRC
#+END_COMMENT

#+BEGIN_SRC dot :file images/lb-rel+acq+rlx.png :var input=make-lb-rel+acq+rlx :exports results
digraph {
 { rank = same; a; b; }
 $input
}
#+END_SRC

** Notes
As it stated in [[LB rel+rlx][LB rel+rlx]] and [[LB acq+rlx][LB acq+rlx]] sections,
it should be possible to get ~r1 = r2 = 1~ executing the LB snippet with
corresponding modifiers (rel+rlx or acq+rlx).
But not in case of [[LB rel+acq+rlx][LB rel+acq+rlx]]. The cause of such restriction is the /sw/
(synchronizes-with) edge, which appears in the corresponding graph,
see Fig. [[fig:LB_rel+acq+rlx]].
Such edge might connect /only/ release writes and acquire reads, which isn't the case
in [[LB rel+rlx][LB rel+rlx]] and [[LB acq+rlx][LB acq+rlx]].

#+BEGIN_SRC dot :file images/lb-acq+rlx-notes.png :exports results
  digraph {
   splines=true;
   overlap=false;
   ranksep = 0.2;
   nodesep = 0.25;
  /* legend */
  fontsize=10 fontname="Helvetica" label=""; 

  { rank = same; nodec; nodee; }

  nodea [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="a:Wrlx x=0", pos="1.000000,3.100000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  nodeb [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="b:Wrlx y=0", pos="1.000000,2.400000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  /* column */

  nodec [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="c:Racq y=1", pos="2.500000,1.700000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  noded [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="d:Wrlx x=1", pos="2.500000,1.000000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  /* column */

  nodee [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="e:Racq x=1", pos="4.000000,1.700000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  nodef [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="f:Wrlx y=1", pos="4.000000,1.000000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
  nodec -> noded [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  nodee -> nodef [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  nodea -> nodeb [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  noded -> nodee [label=<<font color="red">rf</font>>, color="red", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  nodef -> nodec [label=<<font color="red">rf</font>>, color="red", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  // nodeb -> noded [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  // nodea -> nodef [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  nodeb -> nodee [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  nodeb -> nodec [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
  }
#+END_SRC

#+CAPTION: LB acq+rlx (slightly modified output of [[http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/index.html][cppmem]])
#+RESULTS:

#+BEGIN_SRC dot :file images/lb-rel+rlx-notes.png :exports results
digraph G {
 splines=true;
 overlap=false;
 ranksep = 0.2;
 nodesep = 0.25;
/* legend */
fontsize=10 fontname="Helvetica" label=""; 

  { rank = same; nodec; nodee; }
/* columns */
/* column */

nodea [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="a:Wna x=0", pos="1.000000,3.100000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodeb [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="b:Wna y=0", pos="1.000000,2.400000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
/* column */

nodec [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="c:Rrlx y=1", pos="2.500000,3.100000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
noded [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="d:Wrel x=1", pos="2.500000,2.400000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
/* column */

nodee [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="e:Rrlx x=1", pos="4.000000,3.100000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodef [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="f:Wrel y=1", pos="4.000000,2.400000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodec -> noded [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodee -> nodef [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodea -> nodeb [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
noded -> nodee [label=<<font color="red">rf</font>>, color="red", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodef -> nodec [label=<<font color="red">rf</font>>, color="red", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
//nodeb -> noded [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
//nodea -> nodef [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodeb -> nodee [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodeb -> nodec [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
}
#+END_SRC

#+CAPTION: LB rel+rlx (slightly modified output of [[http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/index.html][cppmem]])
#+RESULTS:

#+BEGIN_SRC dot :file images/lb-rel+acq+rlx-notes.png :exports results
digraph G {
 splines=true;
 overlap=false;
 ranksep = 0.2;
 nodesep = 0.25;
/* legend */
fontsize=10 fontname="Helvetica" label=""; 

/* columns */
/* column */
  { rank = same; nodec; nodee; }

nodea [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="a:Wna x=0", pos="1.000000,3.100000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodeb [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="b:Wna y=0", pos="1.000000,2.400000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
/* column */

nodec [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="c:Racq y=1", pos="2.500000,1.700000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
noded [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="d:Wrlx x=1", pos="2.500000,1.000000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
/* column */

nodee [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="e:Rrlx x=1", pos="4.000000,1.700000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodef [shape=plaintext, fontname="Helvetica", fontsize=10]  [label="f:Wrel y=1", pos="4.000000,1.000000!"] [margin="0.0,0.0"][fixedsize="true"][height="0.200000"][width="0.900000"];
nodec -> noded [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodee -> nodef [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodea -> nodeb [label=<<font color="black">sb</font>>, color="black", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
noded -> nodee [label=<<font color="red">rf</font>>, color="red", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
//noded -> nodea [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
//nodef -> nodeb [label=<<font color="blue">mo</font>>, color="blue", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodeb -> nodee [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodeb -> nodec [label=<<font color="deeppink4">asw</font>>, color="deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="0.8"];
nodef -> nodec [label=<<font color="red">rf</font>,<font color="deeppink4">sw</font>>, color="red:deeppink4", fontname="Helvetica", fontsize=10, penwidth=1., arrowsize="1.0"];
}
#+END_SRC

#+NAME: fig:LB_rel+acq+rlx
#+CAPTION: *Incorrect* LB rel+acq+rlx graph, which *violates* acyclicity of /happens-before/ (sb+sw+sb) + /read-from/ (rf) (slightly modified output of [[http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/index.html][cppmem]])
#+RESULTS:
